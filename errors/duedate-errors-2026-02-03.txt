DUE DATE LOG ERROR REPORT
Generated: 2026-02-03T13:42:51.255Z
Date: 2026-02-03
Source File: dueDateLogs-2026-02-03.txt
Status: NO ERRORS FOUND
Detected by: Gemini AI

==============================================
ANALYSIS RESULT:
==============================================

```python
import re

def parse_netsuite_log(log_content):
    """
    Parses NetSuite log content to find SCRIPT ERRORs and extract specific details.

    Args:
        log_content (str): The complete log content as a string.

    Returns:
        str: A formatted string of extracted error details, or "NO ERRORS DETECTED".
    """
    lines = log_content.strip().split('\n')
    errors = []
    
    i = 0
    while i < len(lines):
        line = lines[i]
        
        # Rule 1: ONLY look for lines containing the exact text "SCRIPT ERROR:"
        if "SCRIPT ERROR:" in line:
            error_details = {
                "timestamp": "N/A",
                "type": "Script Error",
                "Bill Payment ID": "N/A",
                "Invoice ID": "N/A",
                "Bill ID": "N/A",
                "Amount": "N/A",
                "UTR Date": "N/A",
                "Error Name": "N/A",
                "Error Message": "N/A"
            }
            
            # Extract timestamp from the SCRIPT ERROR line
            timestamp_match = re.match(r'^\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\].*SCRIPT ERROR:', line)
            if timestamp_match:
                error_details["timestamp"] = timestamp_match.group(1)
            
            # Read subsequent lines for error details
            j = i + 1
            while j < len(lines):
                detail_line = lines[j].strip()
                
                # Stop if a new timestamped log entry begins or if we hit the stack trace
                if re.match(r'^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}\]', detail_line) or detail_line.startswith("Stack:"):
                    break
                
                if detail_line.startswith("Bill Payment ID:"):
                    error_details["Bill Payment ID"] = detail_line.split(":", 1)[1].strip()
                elif detail_line.startswith("Error Name:"):
                    error_details["Error Name"] = detail_line.split(":", 1)[1].strip()
                elif detail_line.startswith("Error Message:"):
                    error_details["Error Message"] = detail_line.split(":", 1)[1].strip()
                elif detail_line.startswith("Parameters Used:"):
                    params_str = detail_line.split(":", 1)[1].strip()
                    
                    # Extract details from Parameters Used line
                    amount_match = re.search(r'billPaymentAmount:\s*(\d+)', params_str)
                    if amount_match:
                        error_details["Amount"] = amount_match.group(1)
                    
                    utr_date_match = re.search(r'utrGeneratedDate:\s*([\d/]+)', params_str)
                    if utr_date_match:
                        error_details["UTR Date"] = utr_date_match.group(1)
                    
                    bill_id_match = re.search(r'billId:\s*(\d+)', params_str)
                    if bill_id_match:
                        error_details["Bill ID"] = bill_id_match.group(1)
                    
                    invoice_id_match = re.search(r'invoiceId:\s*(\d+)', params_str)
                    if invoice_id_match:
                        error_details["Invoice ID"] = invoice_id_match.group(1)
                
                j += 1
            
            errors.append(error_details)
            i = j # Continue scanning from where the error details ended
        else:
            i += 1
            
    if not errors:
        return "NO ERRORS DETECTED"
    
    output = []
    for idx, error in enumerate(errors):
        output.append(f"Error {idx + 1}: {error['timestamp']}")
        output.append(f"   Type: {error['type']}")
        output.append(f"   Bill Payment ID: {error['Bill Payment ID']}")
        output.append(f"   Invoice ID: {error['Invoice ID']}")
        output.append(f"   Bill ID: {error['Bill ID']}")
        output.append(f"   Amount: {error['Amount']}")
        output.append(f"   UTR Date: {error['UTR Date']}")
        output.append(f"   Error Name: {error['Error Name']}")
        output.append(f"   Error Message: {error['Error Message']}")
    
    return "\n".join(output)

# LOG CONTENT provided in the problem description
LOG_CONTENT = """
[2025-09-30 03:42:48.708] 
============================================================
[2025-09-30 03:42:48.710] DUE DATE UPDATE SCRIPT EXECUTION
[2025-09-30 03:42:48.712] Timestamp: 2025-09-30 03:42:48 UTC
[2025-09-30 03:42:48.713] ============================================================

[2025-09-30 03:42:48.715] Bill Payment ID: 5324860
[2025-09-30 03:42:48.716] Script triggered by: view
[2025-09-30 03:42:48.717] User: System

[2025-09-30 03:42:48.866] Bill payment record loaded successfully. Type: vendorpayment, ID: 5324860
[2025-09-30 03:42:48.870] Bill payment amount retrieved: 200
[2025-09-30 03:42:48.894] Payment details - Items Count: 1, Payment Status: Confirmed, Payment Method: 7, UTR Date: 10/8/2025
[2025-09-30 03:42:48.896] CONDITION MET: UTR date exists and payment method is 7 (Sambitron) - Entering UTR Flow
[2025-09-30 03:42

[WARNING: Analysis may be incomplete - response was truncated due to length]

The Due Date system appears to be running normally.

==============================================
END OF REPORT
==============================================