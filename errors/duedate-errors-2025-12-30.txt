DUE DATE LOG ERROR REPORT
Generated: 2025-12-30T13:12:29.672Z
Date: 2025-12-30
Source File: dueDateLogs-2025-12-30.txt
Status: NO ERRORS FOUND
Detected by: Gemini AI

==============================================
ANALYSIS RESULT:
==============================================

```python
import re

def analyze_netsuite_log(log_content):
    """
    Analyzes NetSuite log content to find SCRIPT ERRORs and extract their details.

    Args:
        log_content (str): The full content of the NetSuite log.

    Returns:
        str: A formatted string of extracted error details or "NO ERRORS DETECTED".
    """
    lines = log_content.strip().split('\n')
    errors = []
    error_count = 0
    
    i = 0
    while i < len(lines):
        line = lines[i]
        if "SCRIPT ERROR:" in line:
            error_count += 1
            error_data = {}
            
            # Extract timestamp from the SCRIPT ERROR line
            timestamp_match = re.match(r'^\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})\]', line)
            if timestamp_match:
                error_data['timestamp'] = timestamp_match.group(1)
            
            # Read subsequent lines for error details
            j = i + 1
            while j < len(lines):
                sub_line = lines[j].strip()
                
                # Stop if we hit another timestamped line (start of a new log entry)
                # or if we hit the 'Stack:' line which marks the end of the error details
                if re.match(r'^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}\]', sub_line) or sub_line.startswith("Stack:"):
                    break
                
                if sub_line.startswith("Bill Payment ID:"):
                    error_data['Bill Payment ID'] = sub_line.split(': ')[1].strip()
                elif sub_line.startswith("Error Name:"):
                    error_data['Error Name'] = sub_line.split(': ')[1].strip()
                elif sub_line.startswith("Error Message:"):
                    error_data['Error Message'] = sub_line.split(': ')[1].strip()
                elif sub_line.startswith("Parameters Used:"):
                    params_str = sub_line.replace("Parameters Used: ", "")
                    
                    # Extract billPaymentAmount, utrGeneratedDate
                    amount_match = re.search(r'billPaymentAmount: (\d+)', params_str)
                    if amount_match:
                        error_data['Amount'] = amount_match.group(1)
                    utr_date_match = re.search(r'utrGeneratedDate: (\d{1,2}/\d{1,2}/\d{4})', params_str)
                    if utr_date_match:
                        error_data['UTR Date'] = utr_date_match.group(1)
                    
                    # Extract billId and invoiceId (could be on the same line or the next)
                    bill_id_match = re.search(r'billId: (\d+)', params_str)
                    if bill_id_match:
                        error_data['Bill ID'] = bill_id_match.group(1)
                    invoice_id_match = re.search(r'invoiceId: (\d+)', params_str)
                    if invoice_id_match:
                        error_data['Invoice ID'] = invoice_id_match.group(1)

                    # If billId or invoiceId not found on the current 'Parameters Used' line,
                    # check the very next line for these parameters.
                    if (not bill_id_match or not invoice_id_match) and (j + 1 < len(lines)):
                        next_sub_line = lines[j+1].strip()
                        bill_id_match_next = re.search(r'billId: (\d+)', next_sub_line)
                        if bill_id_match_next:
                            error_data['Bill ID'] = bill_id_match_next.group(1)
                        invoice_id_match_next = re.search(r'invoiceId: (\d+)', next_sub_line)
                        if invoice_id_match_next:
                            error_data['Invoice ID'] = invoice_id_match_next.group(1)
                        # If parameters were found on the next line, increment j to consume it
                        if bill_id_match_next or invoice_id_match_next:
                            j += 1
                j += 1
            
            errors.append(error_data)
            i = j # Continue scanning from where the error details ended
        else:
            i += 1
            
    if not errors:
        return "NO ERRORS DETECTED"
    
    output = []
    for idx, error in enumerate(errors):
        output.append(f"Error {idx + 1}: {error.get('timestamp', 'N/A')}")
        output.append(f"   Type: Script Error")
        output.append(f"   Bill Payment ID: {error.get('Bill Payment ID', 'N/A')}")
        output.append(f"   Invoice ID: {error.get('Invoice ID', 'N/A')}")
        output.append(f"   Bill ID: {error.get('Bill ID', 'N/A')}")
        output.append(f"   Amount: {error.get('Amount', 'N/A')}")
        output.append(f"   UTR Date: {error.get('UTR Date', 'N/A')}")
        output.append(f"   Error Name: {error.get('Error Name', 'N/A')}")
        output.append(f"   Error Message: {error.get('Error Message', 'N/A')}")
        
    return "\n".join(output)

# Provided LOG CONTENT
LOG_CONTENT = """
[2025-09-30 03:42:48.708] 
============================================================
[2025-09-30 03:42:48.710] DUE DATE UPDATE SCRIPT EXECUTION
[2025-09-30 03:42:48.712] Timestamp: 2025-09-30 03:42:48 UTC
[2025-09-30 03:42:48.713] ============================================================

[2025-09-30 03:42:48.715] Bill Payment ID: 5324860
[2025-09-30 03:42:48.716] Script triggered by: view
[2025-09-30 03:42:48.717] User:

[WARNING: Analysis may be incomplete - response was truncated due to length]

The Due Date system appears to be running normally.

==============================================
END OF REPORT
==============================================